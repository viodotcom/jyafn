from .jyafn import *
import abc
import jyafn as fn
import types
from abc import ABC, abstractmethod
from typing import Any, Iterable

class BaseAnnotation(ABC, metaclass=abc.ABCMeta):
    @classmethod
    @abstractmethod
    def __class_getitem__(cls, args) -> types.GenericAlias: ...
    @classmethod
    @abstractmethod
    def make_input(cls, name: str, args: tuple[Any, ...]): ...
    @classmethod
    @abstractmethod
    def make_ret(cls, ret: Any, args: tuple[Any, ...]): ...

class unit:
    @classmethod
    def __class_getitem__(cls, args) -> types.GenericAlias: ...
    @classmethod
    def make_input(cls, name: str, args: tuple[Any, ...]): ...
    @classmethod
    def make_ret(cls, ret: Any, args: tuple[Any, ...]): ...

class scalar(BaseAnnotation):
    @classmethod
    def __class_getitem__(cls, ty: float | bool = ...) -> None: ...
    @classmethod
    def make_input(cls, name: str, args: tuple[Any, ...]): ...
    @classmethod
    def make_ret(cls, ret: Any, args: tuple[Any, ...]): ...

class list(BaseAnnotation):
    @classmethod
    def __class_getitem__(cls, size: int) -> None: ...
    @classmethod
    def make_input(cls, name: str, args: tuple[Any, ...]): ...
    @classmethod
    def make_ret(cls, ret: Any, args: tuple[Any, ...]): ...

class symbol(BaseAnnotation):
    @classmethod
    def __class_getitem__(cls, args) -> None: ...
    @classmethod
    def make_input(cls, name: str, args: tuple[Any, ...]): ...
    @classmethod
    def make_ret(cls, ret: Any, args: tuple[Any, ...]): ...

class tensor(BaseAnnotation):
    @classmethod
    def __class_getitem__(cls, shape: tuple[int]) -> None: ...
    @classmethod
    def make_input(cls, name: str, args: tuple[Any, ...]): ...
    @classmethod
    def make_ret(cls, ret: Any, args: tuple[Any, ...]): ...

def func(f) -> fn.Function: ...
def min(x: Iterable[fn.Ref]) -> fn.Ref: ...
def max(x: Iterable[fn.Ref]) -> fn.Ref: ...
def acos(*args, **kwargs): ...
def acosh(*args, **kwargs): ...
def asin(*args, **kwargs): ...
def asinh(*args, **kwargs): ...
def assert_(*args, **kwargs): ...
def atan(*args, **kwargs): ...
def atanh(*args, **kwargs): ...
def besseli(*args, **kwargs): ...
def besselj(*args, **kwargs): ...
def bessely(*args, **kwargs): ...
def beta(*args, **kwargs): ...
def ceil(*args, **kwargs): ...
def const(*args, **kwargs): ...
def cos(*args, **kwargs): ...
def cosh(*args, **kwargs): ...
def current_graph(*args, **kwargs): ...
def digamma(*args, **kwargs): ...
def erf(*args, **kwargs): ...
def erfc(*args, **kwargs): ...
def exp(*args, **kwargs): ...
def factorial(*args, **kwargs): ...
def floor(*args, **kwargs): ...
def gamma(*args, **kwargs): ...
def gammac(*args, **kwargs): ...
def gammac_inv(*args, **kwargs): ...
def gammainc(*args, **kwargs): ...
def input(*args, **kwargs): ...
def is_finite(*args, **kwargs): ...
def is_infinite(*args, **kwargs): ...
def is_nan(*args, **kwargs): ...
def list_input(*args, **kwargs): ...
def ln(*args, **kwargs): ...
def logbeta(*args, **kwargs): ...
def loggamma(*args, **kwargs): ...
def mapping(*args, **kwargs): ...
def norm(*args, **kwargs): ...
def norm_inv(*args, **kwargs): ...
def pow(*args, **kwargs): ...
def powf(*args, **kwargs): ...
def putative_layout(*args, **kwargs): ...
def rem(*args, **kwargs): ...
def ret(*args, **kwargs): ...
def rgamma(*args, **kwargs): ...
def riemann_zeta(*args, **kwargs): ...
def round(*args, **kwargs): ...
def sin(*args, **kwargs): ...
def sinh(*args, **kwargs): ...
def sqrt(*args, **kwargs): ...
def symbol_input(*args, **kwargs): ...
def tan(*args, **kwargs): ...
def tanh(*args, **kwargs): ...
def trunc(*args, **kwargs): ...
